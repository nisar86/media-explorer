<?php
/*
 *
 * Media Explorer
 * by Nisar Abed (info@nisar.it | Nisar.it)
 * 
 * - Endpoint: server-list-files.php
 * - By default, to enable this script you must set a valid value (not null) for $directory.
 *   You can specify either a directory path or the web server document root.
 * - Returns a JSON with the list of items in the specified server directory.
 * - Optional GET parameter: ?sub=relative/path/to/base (relative to the document root).
 *   The JS app uses this to access subdirectories. 
 * 
 */
// Enable strict typing.
declare(strict_types=1);
// Response headers.
header('Content-Type: application/json; charset=utf-8');
// Allow cross-origin requests (CORS).
header('Access-Control-Allow-Origin: *');


/*
 *
 * Set Directory
 * Sets the path to the directory the app can display and navigate.
 * Example:
 * - null         --> (default) No directories exposed, browsing disabled.
 * - '/directory' --> Relative path to web server directory.
 * - ''           --> Document root of the web server.
 * 
 * Security notice: 
 * WARNING: do not expose the server root or sensitive directorys (especially if the server is online). 
 * Ensure the directory does not contain confidential files before making it public.
 * 
 */
// ###############
$directory = null;
// ###############


if ($directory===null) {
    // Directory not set (Default)
    http_response_code(500);
    echo json_encode(['error' => '500_DIR_NOT_SETTED', 'desc' => 'Directory not setted.']);
    exit;
}


// Determine the exploration base (document root).
$docRoot = realpath($_SERVER['DOCUMENT_ROOT'] ?? '') ?: '';
if ($docRoot === '' || !is_dir($docRoot)) {
    // If the document root is invalid, terminate the script.
    http_response_code(500);
    echo json_encode(['error' => '500_DOC_ROOT_NOT_FOUND', 'desc' => 'Document root not found.']);
    exit;
}


// Base Dir
// Use the document root as the base directory (Default) or use a directory.
$baseDir = $docRoot.$directory;


// Read and normalize the optional GET parameter "sub" (relative path).
$sub = '';
// If "sub" is present.
if (isset($_GET['sub'])) {
    $rawSub = trim((string)$_GET['sub']); // Treat the value as a string and remove accidental spaces.
    $rawSub = str_replace("\0", '', $rawSub); // Remove any NUL characters.
    $rawSub = trim($rawSub, " \t\n\r\0\x0B/\\"); // Remove common whitespace and slash characters.
    $sub = $rawSub; // Clean value.
}


// Build target path: base + (optional sub)
$targetDir = $baseDir.($sub === '' ? '' : DIRECTORY_SEPARATOR.$sub);
// Normalize path, returns FALSE if path doesn't exist.
$realTarget = realpath($targetDir);
// Validate
// 1) Realpath succeeded. 2) It's a directory. 3) Path stays inside the allowed baseDir.
if ( $realTarget === false || !is_dir($realTarget) || strpos($realTarget, $baseDir) !== 0 ) {
    http_response_code(400);
    echo json_encode(['error' => '400_INVALID_PATH', 'desc' => 'Invalid path.']);
    exit;
}


// Read the directory contents.
// The scandir() function on the $realTarget path returns an array of the names (strings) of the items present in the directory.
// The @ before scandir suppresses any warnings/notices generated by PHP, such as permission denied or unreadable path.
$items = @scandir($realTarget);
if ($items === false) {
    http_response_code(500);
    echo json_encode(['error' => '500_UNABLE_READ_DIR', 'desc' => 'Unable to read directory.']);
    exit;
}


// Helper: Returns the MIME type of a file.
function safe_mime(string $file): string {
    $m = @mime_content_type($file);
    return $m ? $m : 'application/octet-stream';
}


/*
 * 
 * Search the directory $dirFull for the first image file (image/) or the first video file (video/).
 * If found, return an array ['preview' => '/web/path', 'type' => 'mime/type'] or null.
 * $maxCheck limits the number of files analyzed for performance reasons. (0 = no limit).
 * 
 */
function find_preview_in_dir(string $dirFull, string $docRoot, int $maxCheck = 200) {
    // Try to read the directory contents.
    // @scandir obtains an array with the names of the items in the directory,
    // suppressing any warnings/notices (with @) such as an unreadable directory. 
    $items = @scandir($dirFull);
    if ($items === false) return null;
    // Sort items by name (case-insensitive).
    sort($items, SORT_NATURAL | SORT_FLAG_CASE);
    $checked = 0; // Counter of files checked.

    // Pass 1: Search for images.
    foreach ($items as $n) {
        // Skip dotfiles (files starting with a dot).
        if ($n === '.' || $n === '..') continue;
        if ($n !== '' && $n[0] === '.') continue;
        // Build the file's full path.
        $full = $dirFull . DIRECTORY_SEPARATOR . $n;
        if (is_link($full)) continue; // Do not follow symlinks (symbolic links).
        if (!is_file($full)) continue; // Consider only files (skip directories).
        $checked++; // Increment the counter.
        // If a limit is set and it has been exceeded, exit the loop.
        if ($maxCheck > 0 && $checked > $maxCheck) break;
        // Try to obtain the MIME type.
        $mime = @mime_content_type($full) ?: '';
        // If the MIME is defined and starts with 'image/', we have found an image preview.
        if ($mime && strpos($mime, 'image/') === 0) {
            // If the file's absolute path starts with $docRoot we can create a web path.
            if (strpos($full, $docRoot) === 0) {
                // Remove the $docRoot portion and convert directory separators to '/'.
                $webPath = str_replace(DIRECTORY_SEPARATOR, '/', substr($full, strlen($docRoot)));
                // Ensure it starts with a slash.
                $webPath = '/' . ltrim($webPath, '/');
            } else {
                // If the file is not under docRoot we cannot create a valid web path.
                $webPath = '';
            }
            // Return the array with the preview path and the MIME type.
            return ['preview' => $webPath, 'type' => $mime];
        }
    }

    // Pass 2: Search for videos.
    // If no images were found...
    $checked = 0; // Reset the counter for the new search.
    // Same loop as for images but for videos...
    foreach ($items as $n) {
        if ($n === '.' || $n === '..') continue;
        if ($n !== '' && $n[0] === '.') continue;
        $full = $dirFull . DIRECTORY_SEPARATOR . $n;
        if (is_link($full)) continue;
        if (!is_file($full)) continue;
        $checked++;
        if ($maxCheck > 0 && $checked > $maxCheck) break;
        $mime = @mime_content_type($full) ?: '';
        // If the MIME is defined and starts with 'video/', we have found a video preview.
        if ($mime && strpos($mime, 'video/') === 0) {
            if (strpos($full, $docRoot) === 0) {
                $webPath = str_replace(DIRECTORY_SEPARATOR, '/', substr($full, strlen($docRoot)));
                $webPath = '/' . ltrim($webPath, '/');
            } else {
                $webPath = '';
            }
            return ['preview' => $webPath, 'type' => $mime];
        }
    }

    // If neither images nor videos were found, return null.
    return null;
}


// Construct the results list.
$result = [];


// Loop over all found items.
foreach ($items as $name) {
    // Exclude '.' and '..' and dotfiles.
    if ($name === '.' || $name === '..') continue;
    if ($name !== '' && $name[0] === '.') continue; // Hide dotfiles.
    // Construct the full filesystem path:
    // 1) Absolute path of the current directory ($realTarget) + 2) System directory separator + 3) Item name.
    $full = $realTarget.DIRECTORY_SEPARATOR.$name;
    // Do not follow symlinks.
    if (is_link($full)) continue;
    // Determine whether the item is a directory or a file.
    $isDir = is_dir($full);
    $isFile = is_file($full);
    // Build the relative path ($relPath) of this element with respect to the current "base" (sub).
    // Example: If in root 'file.jpg'; if in a subdirectory 'subdirectory/file.jpg'.
    $relPath = ($sub === '' ? $name : ($sub.'/'.$name));
    // Prepare the entry with the common fields.
    // $entry is an associative array representing a single entry (file or folder) in the list; it contains the metadata used by the client/UI.
    // Its practical purpose is to have a uniform, serializable structure (later converted to JSON) that the front-end or any API consumer can easily read.
    $entry = [
        'name'     => $name,    // Element Name.
        'is_dir'   => $isDir,   // If is directory.
        'size'     => $isFile ? @filesize($full) : 0,  // File size.
        'modified' => @filemtime($full) ? date('c', @filemtime($full)) : null,        // Modification date.
        'ext'      => $isFile ? strtolower(pathinfo($name, PATHINFO_EXTENSION)) : '', // File extension.
        'mime'     => $isFile ? safe_mime($full) : '', // MIME Type.
        'relpath'  => $relPath, // Relative path.
        'url'      => '', // Public URL (used only for files located under the document root, i.e., accessible via HTTP).
        'folder_preview' => null, // Folder preview (used only for directories).
    ];

    // Construct entry['url'].
    // If it is a file and is located under the server's document root.
    if ($isFile && strpos($full, $docRoot) === 0) {
        // Remove the physical document root portion to obtain the relative path.
        $webPath = str_replace(DIRECTORY_SEPARATOR, '/', substr($full, strlen($docRoot)));
        // Ensure it starts with a single slash (e.g. '/subdir/file.txt').
        $webPath = '/' . ltrim($webPath, '/');
        // Store the URL usable by the browser.
        $entry['url'] = $webPath;
    }

    // If it is a directory, try to find a preview in the first inner level.
    // First search for an image; if none is found, search for a video; return null if nothing is found.
    if ($isDir) {
        $maxCheckFiles = 200; // Max files checked.
        $subPreview = find_preview_in_dir($full, $docRoot, $maxCheckFiles);
        // array {preview:'/path', type:'mime'} or null.
        $entry['folder_preview'] = $subPreview;
    }

    // Add the entry to the results array.
    $result[] = $entry;
}


// Sort folders and files alphabetically (case-insensitive)
// List folders first, then files.
usort($result, function($a, $b) {
    // If A is a directory and B is not -> A comes first.
    if ($a['is_dir'] && !$b['is_dir']) return -1;
    // If A is not a directory and B is -> B comes first (so A after).
    if (!$a['is_dir'] && $b['is_dir']) return 1;
    // If both items are the same type,
    // compare their names case-insensitively and sort alphabetically.
    return strcasecmp($a['name'], $b['name']);
});


// Output JSON
// Return to the client the JSON with the key entries containing the ordered array.
// JSON_UNESCAPED_UNICODE: keeps UTF-8 readable (e.g. accented characters).
// JSON_UNESCAPED_SLASHES: prevents escaping of slashes (/) in URL paths.
echo json_encode(['entries' => $result], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
